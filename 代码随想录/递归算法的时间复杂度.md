题：求 x 的 n 次方

- 最简单的方法，for 循环，复杂度 O(n)

```python
def f1(x, n):
    result = 1  # 注意，考虑 n=0 的情况
    for _ in range(n):
        result = result * x
    return result
```

有没有效率更好的算法呢？

- 考虑一下递归

```python
def f2(x, n):
    if n == 0:
        return 1
    return f2(x, n - 1) * x
```

这个代码的时间复杂度是多少？递归不一定是 O(logn)，递归算法的时间复杂度本质上是要看： **递归的次数 \* 每次递归中的操作次数**，在这个递归里面，递归了n次时间复杂度是 O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度一个常数项 O(1)，所以这份代码的时间复杂度是 n * 1 = O(n)，没有什么变化

- 尝试一下另一种递归（二分递归？）

```python
def f3(x, n):
    if n == 0:
        return 1
    if n % 2 == 1:
        return f3(x, n/2) * f3(x, n/2) * x
    return f3(x, n/2) * f3(x, n/2)
```

这种递归可以抽象出一颗满二叉树，树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点，m 层满二叉树有 2^m-1 个节点，而 m=log2n，所以总共有 n - 1 个节点，复杂度仍然为 O(n)，其实想一下， 虽然每次二分了，但是最后仍然每一部分都算了一遍。

- 再次简化

```python
def f4(x, n):
    if n == 0:
        return 1
    t = f4(x, n/2)	# 这里相对于f3，是把这个递归操作抽取出来
    if n % 2 == 1:
        return t * t * x
    return t * t
```

这里每次除以2，一共递归了 log2n 次，每次递归做一次乘法运算，所以复杂度为 O(logn)，这个与 f3 相比，其实就是递归一次得到的结果供二分两边使用，写 f3 的时候应该要想到这一点。

- 空间复杂度优化

其实不用递归，n是奇数的时候取出一个乘到结果上，剩下偶数继续二分（2^4^ = (2*2)^2^， x=x\*x, n = n//2）

```python
def f5(x, n):
    res = 1
    while n > 0:
        # n是奇数时取出一个乘到结果上
        if n % 2 == 1:
            res *= x
        # 底数平方，指数//2
        x *= x
        n //= 2
    return res
```

